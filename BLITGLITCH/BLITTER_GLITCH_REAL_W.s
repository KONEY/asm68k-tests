;*** MiniStartup by Photon ***
	INCDIR	"NAS:AMIGA/CODE/crippled_cyborg_amiga/"
	SECTION	"Code",CODE
	INCLUDE	"PhotonsMiniWrapper1.04!.S"
	INCLUDE	"Blitter-Register-List.S"	;use if you like ;)
	INCLUDE	"PT12_OPTIONS.i"
	INCLUDE	"P6112-Play-stripped.i"
;********** Constants **********
PAD_TOP=	12
PAD_BOT= 8
w_real=	320
w=	320		; screen width
h=	234		; screen height
bpls=	4		; depth
bpl=	w/16*2		; byte-width of 1 bitplane line (40bytes)
bwid=	bpls*bpl		; byte-width of 1 pixel line (all bpls)
blitsize=	h*64+w/16	; size of blitter operation
blitsizeF=%000000000000010101	; size of FULL blitter operation
bplsize=	bpl*h		; size of 1 bitplane screen
hband=	10		; lines reserved for textscroller
hblit=	h/2		;-hband	; size of blitter op without textscroller
wblit=	w/2/16*2
bpl_real=	w/16*2
vbarwbpl=	w/10/16
Y_SLIDE=18
Y_SLIDEPR=13
;*************
MODSTART_POS=0		; start music at position # !! MUST BE EVEN FOR 16BIT
;*************
;CLR.W	$100		; DEBUG | w 0 100 2
;********** Demo **********	;Demo-specific non-startup code below.
Demo:				;a4=VBR, a6=Custom Registers Base addr
	;*--- init ---*
	MOVE.L	#VBint,$6C(A4)
	MOVE.W	#%1110000000100000,INTENA
	;** SOMETHING INSIDE HERE IS NEEDED TO MAKE MOD PLAY! **
	MOVE.W	#%1000001111100000,DMACON	; BIT10=BLIT NASTY
	;MOVE.W	MODSTART_POS,D3
	;CMP.W	#0,D3
	;BEQ.S	.dontDisableBlitterNasty	; IF START > 0 DISABLE BLIT NASTY NOW
	;MOVE.W	#%0000010000000000,DMACON	; BIT10=BLIT NASTY DISABLED
	;.dontDisableBlitterNasty:
	;*--- clear screens ---*
	;LEA	SCREEN1,A1
	;BSR.W	ClearScreen
	;LEA	SCREEN2,A1
	;BSR.W	ClearScreen
	BSR	WaitBlitter
	;*--- start copper ---*
	MOVEQ	#0,D0
	;########################
	LEA	HEADER,A0
	LEA	COPPER\.BplPtrs+2,A1
	MOVEQ	#0,D1
	BSR.W	PokePtrs
	LEA	HEADER,A0
	MOVEQ	#0,D1
	BSR.W	PokePtrs
	LEA	HEADER,A0
	MOVEQ	#0,D1
	BSR.W	PokePtrs
	LEA	HEADER,A0
	MOVEQ	#0,D1
	BSR.W	PokePtrs
	;########################
	MOVEM.L	BGPLANE0,A0
	LEA	COPPER\.BplPtrs2+2,A1
	MOVEQ	#0,D1
	BSR.W	PokePtrs
	MOVEM.L	BGPLANE1,A0
	MOVEQ	#0,D1
	BSR.W	PokePtrs
	MOVEM.L	BGPLANE0,A0
	ADD.L	#bpl,A0
	MOVEQ	#0,D1
	BSR.W	PokePtrs
	MOVEM.L	BGPLANE3,A0
	MOVEQ	#0,D1
	BSR.W	PokePtrs
	;########################
	LEA	FOOTER,A0
	LEA	COPPER\.BplPtrs3+2,A1
	MOVEQ	#0,D1
	BSR.W	PokePtrs
	LEA	FOOTER,A0
	MOVEQ	#0,D1
	BSR.W	PokePtrs
	LEA	FOOTER,A0
	MOVEQ	#0,D1
	BSR.W	PokePtrs
	LEA	FOOTER,A0
	MOVEQ	#0,D1
	BSR.W	PokePtrs

	; #### CPU INTENSIVE TASKS BEFORE STARTING MUSIC
	;JSR	__CREATESCROLLSPACE

	MOVE.L	DITHERPLANE,SCROLL_DEST	; FILLS A PLANE
	BSR.W	__DITHER_PLANE		; WITH DITHERING

	MOVE.L	#HEADER,SCROLL_DEST
	BSR.W	__DBLBMP

	MOVE.L	GLITCHGOOD,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST
	MOVE.B	#0,X_SHIFT
	MOVE.B	#1,X_DIR
	;BSR.W	__SCROLL_X
	MOVE.B	#0,X_DIR
	;BSR.W	__SCROLL_X

	MOVE.L	DITHERPLANE,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST
	MOVE.B	#1,X_DIR
	BSR.W	__SCROLL_X
	MOVE.B	#0,X_DIR
	BSR.W	__SCROLL_X

	;BRA.W	.pointCopper
	; #### CPU INTENSIVE TASKS BEFORE STARTING MUSIC

	;---  Call P61_Init  ---
	;MOVEM.L	D0-A6,-(SP)
	;LEA	MODULE,A0
	;SUB.L	A1,A1
	;SUB.L	A2,A2
	;MOVE.W	#MODSTART_POS,P61_InitPos	; TRACK START OFFSET
	;JSR	P61_Init
	;MOVEM.L (SP)+,D0-A6

	.pointCopper:
	MOVE.L	#COPPER,$80(A6)
;********************  main loop  ********************
MainLoop:
	;BSR.W	__COPCOL_EDIT	; EDITS COPPER COLORS
	move.w	#$12c,d0		; No buffering, so wait until raster
	bsr.w	WaitRaster	; is below the Display Window.
	;*--- swap buffers ---*
	;movem.l	DrawBuffer(PC),a2-a3
	;exg	a2,a3
	;movem.l	a2-a3,DrawBuffer	;draw into a2, show a3
	;*--- show one... ---*
	;move.l	a3,a0
	;move.l	#bpl*h,d0
	;lea	COPPER\.BplPtrs+2,a1
	;moveq	#bpls-1,d1
	;bsr.w	PokePtrs
	;*--- ...draw into the other(a2) ---*
	;move.l	a2,a1
	; do stuff here :)

	; **** JOYSTICK TEST ****
	;BRA.W	.SkipJoyActions
	MOVEM.W	$DFF00C,D0	; FROM EAB
	ANDI.W	#$0303,D0
	MOVE.W	D0,D1
	ADD.W	D1,D1
	ADDI.W	#$0101,D0
	ADD.W	D1,D0

	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST

	BTST	#9,D0		; 9 LEFT
	BEQ.S	.notLeft
	MOVE.L	BGPLANE1,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST
	.notLeft:
	BTST	#1,D0		; 1 RIGHT
	BEQ.S	.notRight
	.notRight:
	BTST	#2,D0		; 10 UP
	BEQ.S	.notDown
	.notDown:
	BTST	#10,D0		; 2 DOWN
	BEQ.S	.notUp
	.notUp:
	BTST	#$07,$BFE001	; FIRE
	BNE.W	.notFire
	;BSR.W	__DITHER_PLANE		; WITH DITHERING
	MOVE.W	#2,P61_LAST_POS
	.notFire:
	.SkipJoyActions:
	; **** JOYSTICK TEST ****

	SONG_BLOCKS_EVENTS:
	;* FOR TIMED EVENTS ON BLOCK ****
	MOVE.W	P61_LAST_POS,D5
	LEA	TIMELINE,A3
	;MULU.W	#4,D5		; CALCULATES OFFSET FROM SONGPOSITION
	LSL.W	#2,D5		; CALCULATES OFFSET (OPTIMIZED)
	MOVE.L	(A3,D5),A4	; THANKS HEDGEHOG!!
	JSR	(A4)		; EXECUTE SUBROUTINE BLOCK#
	;*--- main loop end ---*

	ENDING_CODE:
	BTST	#6,$BFE001
	BNE.S	.DontShowRasterTime
	;MOVE.W	$DFF006,$DFF180	; show rastertime left down to $12c
	MOVE.B	X_DIR,D5
	NEG.B	D5
	MOVE.B	D5,X_DIR
	MOVE.B	X_PROGR_DIR,D5
	NEG.B	D5
	MOVE.B	D5,X_PROGR_DIR
	;MOVE.B	X_PROGR_TYPE,D5
	;NEG.B	D5
	;MOVE.B	D5,X_PROGR_TYPE
	.DontShowRasterTime:
	BTST	#2,$DFF016	; POTINP - RMB pressed?
	BNE.W	MainLoop		; then loop
	;*--- exit ---*
	;;    ---  Call P61_End  ---
	;MOVEM.L D0-A6,-(SP)
	;JSR P61_End
	;MOVEM.L (SP)+,D0-A6
	RTS

;********** Demo Routines **********
PokePtrs:					; Generic, poke ptrs into copper list
	.bpll:	
	move.l	a0,d2
	swap	d2
	move.w	d2,(a1)		;high word of address
	move.w	a0,4(a1)		;low word of address
	addq.w	#8,a1		;skip two copper instructions
	add.l	d0,a0		;next ptr
	dbf	d1,.bpll
	rts

ClearScreen:				; a1=screen destination address to clear
	bsr	WaitBlitter
	clr.w	$66(a6)			; destination modulo
	move.l	#$01000000,$40(a6)		; set operation type in BLTCON0/1
	move.l	a1,$54(a6)		; destination address
	move.l	#blitsize*bpls,$58(a6)	;blitter operation size
	rts

VBint:					; Blank template VERTB interrupt
	movem.l	d0/a6,-(sp)	; Save used registers
	lea	$dff000,a6
	btst	#5,$1f(a6)	; check if it's our vertb int.
	beq.s	.notvb
	;*--- do stuff here ---*
	moveq	#$20,d0		; poll irq bit
	move.w	d0,$9c(a6)
	move.w	d0,$9c(a6)
	.notvb:	
	movem.l	(sp)+,d0/a6	; restore
	rte

__DBLBMP:
	LEA	KONEY,A1
	MOVE.L	SCROLL_DEST,A5
	MOVE.W	#$9,D6
	.DBLBMP:			; LOGICA PER RADDOPPIARE LA BITMAP
	MOVE.W	(A1)+,D0		
	;****************
	CLR.L	D1
	MOVE.W	#$F,D7
	.LOOP:	
	BTST	D7,D0
	BEQ.S	.NEXT
	MOVE.W	D7,D2
	ADD.W	D2,D2
	BSET	D2,D1
	ADDQ.W	#1,D2
	BSET	D2,D1
	.NEXT:	
	DBRA	D7,.LOOP
	;*****************
	ADD.W	#bpl,A5
	MOVE.L	D1,(A5)
	SUB.W	#bpl,A5
	MOVE.L	D1,(A5)+
	BTST	#0,D6
	BNE.S	.skip
	ADD.W	#bpl,A5
	ADD.W	#bpl-8,A5
	.skip:
	DBRA	D6,.DBLBMP
	RTS

__DITHER_PLANE:
	;ADD.L	#(h-1)*bpl,SCROLL_DEST
	MOVE.L	SCROLL_DEST,A4
	MOVE.W	#h-1,D4		; QUANTE LINEE
	MOVE.L	#$AAAAAAAA,D5
	.outerloop:		; NUOVA RIGA
	MOVE.W	#(bpl/4)-1,D6	; RESET D6
	NOT.L	D5
	.innerloop:		; LOOP KE CICLA LA BITMAP
	MOVE.L	D5,(A4)+
	DBRA	D6,.innerloop
	DBRA	D4,.outerloop
	RTS

__RANDOMIZE_PLANE:
	MOVE.L	SCROLL_DEST,A4
	MOVE.W	#bpl/2*h-1,D4	; QUANTE LINEE
	.innerloop:		; LOOP KE CICLA LA BITMAP
	BSR.S	_RandomWord
	ROL.W	D4,D5
	MOVE.W	D5,(A4)+
	DBRA	D4,.innerloop
	RTS

	_RandomWord:	
	bsr	_RandomByte
	rol.w	#8,d5
	_RandomByte:
	move.b	$dff007,d5	;$dff00a $dff00b for mouse pos
	move.b	$bfd800,d3
	eor.b	d3,d5
	rts

__CREATESCROLLSPACE:
	MOVEM.L	D0-A6,-(SP)	; SAVE TO STACK
	MOVEQ	#bpls-1,D1	; UGUALI PER TUTTI I BITPLANE
	MOVE.L	#%00000000111111110000000000000000,D2	
	MOVE.L	SCROLL_DEST,A4
	.OUTERLOOP:
	MOVEQ	#0,D6		; RESET D6
	MOVE.W	#bpl*hband-1,D6
	ADD.W	#bpl*(hblit),A4	; POSITIONING
	.INNERLOOP:
	MOVE.B	D2,(A4)+	
	DBRA	D6,.INNERLOOP
	ROR.L	#8,D2		; LAST BITPLANE FILLED
	DBRA	D1,.OUTERLOOP
	MOVEM.L	(SP)+,D0-A6	; FETCH FROM STACK
	RTS

__SET_PT_VISUALS:
	; ## MOD VISUALIZERS ##########
	ifne visuctrs
	MOVEM.L D0-A6,-(SP)

	; ## COMMANDS 80x TRIGGERED EVENTS ##
	MOVE.W	P61_1F,D2		; 1Fx
	CMPI.W	#4,D2		; 1F4 - INVERT DIRECTION CH 3
	BNE.S	.keepDir0
	MOVE.B	SCROLL_DIR_0,D1
	NOT	D1
	MOVE.B	D1,SCROLL_DIR_0
	MOVE.W	#0,P61_1F		; RESET FX
	.keepDir0:
	MOVE.W	P61_E8,D2		; 80x
	CMPI.W	#4,D2		; 804 - INVERT DIRECTION CH 3
	BNE.S	.keepDir3
	MOVE.B	SCROLL_DIR_3,D1
	NOT	D1
	MOVE.B	D1,SCROLL_DIR_3
	MOVE.W	#0,P61_E8	; RESET FX
	.keepDir3:
	MOVE.W	P61_E8,D2		; 80x
	CMPI.W	#1,D2		; 804 - INVERT DIRECTION CH 3
	BNE.S	.keepDir1
	MOVE.B	SCROLL_DIR_1,D1
	NOT	D1
	MOVE.B	D1,SCROLL_DIR_1
	MOVE.W	#0,P61_E8	; RESET FX
	.keepDir1:
	; ## COMMANDS 80x TRIGGERED EVENTS ##

	; GLITCH
	LEA	P61_visuctr0(PC),A0 ; which channel? 0-3
	MOVEQ	#45,D0		; maxvalue
	SUB.W	(A0),D0		; -#frames/irqs since instrument trigger
	BPL.S	.ok5		; below minvalue?
	MOVEQ	#0,D0		; then set to minvalue
	.ok5:
	CMPI.W	#16,D0
	BLO.S	.keepValue
	MOVEQ	#15,D0
	.keepValue:	
	MOVE.B	D0,AUDIOCHLEVEL0NRM
	_ok5:

	; GLITCH
	LEA	P61_visuctr0(PC),A0 ; which channel? 0-3
	MOVEQ	#30,D0		; maxvalue
	SUB.W	(A0),D0		; -#frames/irqs since instrument trigger
	BPL.S	.ok0		; below minvalue?
	MOVEQ	#0,D0		; then set to minvalue
	.ok0:
	MOVE.B	D0,AUDIOCHLEVEL0
	_ok0:

	; KICK
	LEA	P61_visuctr1(PC),A0 ; which channel? 0-3
	MOVEQ	#8,D0		; maxvalue
	SUB.W	(A0),D0		; -#frames/irqs since instrument trigger
	BPL.S	.ok1		; below minvalue?
	MOVEQ	#0,D0		; then set to minvalue
	.ok1:
	MOVE.B	D0,AUDIOCHLEVEL1
	MULU.W	#$2,D0		; start from a darker shade
	MOVE.L	D0,D3
	ROL.L	#$4,D3		; expand bits to green
	ADD.L	D3,D0
	ROL.L	#$4,D3
	ADD.L	D3,D0		; expand bits to red
	_ok1:

	; BASS
	LEA	P61_visuctr2(PC),A0 ; which channel? 0-3
	MOVEQ	#15,D0		; maxvalue
	SUB.W	(A0),D0		; -#frames/irqs since instrument trigger
	BPL.S	.ok2		; below minvalue?
	MOVEQ	#0,D0		; then set to minvalue
	.ok2:
	MOVE.B	D0,AUDIOCHLEVEL2
	_ok2:

	; CYBORG
	LEA	P61_visuctr3(PC),A0 ; which channel? 0-3
	MOVEQ	#15,D0		; maxvalue
	SUB.W	(A0),D0		; -#frames/irqs since instrument trigger
	BPL.S	.ok3		; below minvalue?
	MOVEQ	#0,D0		; then set to minvalue
	.ok3:
	MOVE.B	D0,AUDIOCHLEVEL3
	;CMP.W	#15,D0
	;BLO.W	.keepValue
	;MOVE.B	SCROLL_DIR_3,D1
	;NOT	D1
	;MOVE.B	D1,SCROLL_DIR_3
	;.keepValue:
	_ok3:

	MOVEM.L (SP)+,D0-A6
	RTS
	endc
	; MOD VISUALIZERS *****

__POPULATETXTBUFFER:
	MOVEM.L	D0-A6,-(SP)	; SAVE TO STACK
	MOVE.W	FRAMESINDEX,D7
	CMP.W	#4,D7
	BNE.W	.SKIP
	MOVE.L	BGPLANE3,A4
	LEA	FONT,A5
	LEA	TEXT,A6
	ADD.W	#bpl*(hblit),A4	; POSITIONING
	ADD.W	TEXTINDEX,A6
	CMP.L	#_TEXT-1,A6	; Siamo arrivati all'ultima word della TAB?
	BNE.S	.PROCEED
	MOVE.W	#0,TEXTINDEX	; Riparti a puntare dalla prima word
	LEA	TEXT,A6		; FIX FOR GLITCH (I KNOW IT'S FUN... :)
	.PROCEED:
	MOVE.B	(A6),D2		; Prossimo carattere in d2
	SUB.B	#$20,D2		; TOGLI 32 AL VALORE ASCII DEL CARATTERE, IN
	MULU.W	#8,D2		; MOLTIPLICA PER 8 IL NUMERO PRECEDENTE,
	ADD.W	D2,A5
	MOVEQ	#0,D6		; RESET D6
	MOVE.B	#8-1,D6
	.LOOP:
	ADD.W	#bpl-2,A4		; POSITIONING
	MOVE.B	(A5)+,(A4)+
	MOVE.B	#%00000000,(A4)+	; WRAPS MORE NICELY?
	DBRA	D6,.LOOP
	ADD.W	#bpl*2-2,A4	; POSITIONING
	MOVE.B	#%00000000,(A4)	; WRAPS MORE NICELY?
	.SKIP:
	SUB.W	#1,D7
	CMP.W	#0,D7
	BEQ.W	.RESET
	MOVE.W	D7,FRAMESINDEX
	MOVEM.L	(SP)+,D0-A6	; FETCH FROM STACK
	RTS
	.RESET:
	ADD.W	#1,TEXTINDEX
	MOVE.W	#4,D7
	MOVE.W	D7,FRAMESINDEX	; OTTIMIZZABILE
	MOVEM.L	(SP)+,D0-A6	; FETCH FROM STACK
	RTS

__SHIFTTEXT:
	MOVEM.L	D0-A6,-(SP)	; SAVE TO STACK
	bsr	WaitBlitter

	MOVE.L	BGPLANE3,A4
	ADD.W	#bpl*h-2,A4	; POSITIONING
	MOVE.W	#$FFFF,BLTAFWM	; BLTAFWM lo spiegheremo dopo
	MOVE.W	#$FFFF,BLTALWM	; BLTALWM lo spiegheremo dopo
	MOVE.W	#%0010100111110000,BLTCON0	; BLTCON0 (usa A+D); con shift di un pixel
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 BIT 12 DESC MODE
	MOVE.W	#0,BLTAMOD	; BLTAMOD =0 perche` il rettangolo
	MOVE.W	#0,BLTDMOD	; BLTDMOD 40-4=36 il rettangolo

	MOVE.L	A4,BLTAPTH	; BLTAPT  (fisso alla figura sorgente)
	MOVE.L	A4,BLTDPTH

	MOVE.W	#(hband-1)*64+w/16,BLTSIZE	; BLTSIZE (via al blitter !)

	MOVEM.L	(SP)+,D0-A6	; FETCH FROM STACK
	RTS

__BLIT_GLITCH_TILE:
	MOVE.W	GLITCH_INDEX,D2
	LEA	GLITCHDESTTABLE,A1
	MOVE.L	(A1,D2.W),A4
	ADD.W	#2,D2
	AND.W	#16-1,D2
	MOVE.W	D2,GLITCH_INDEX

	;MOVE.W	#%0000100111110000,D1
	MOVE.W	#%00001111111001010,D1	; for texture?
	; ## MAIN BLIT ####
	MOVE.L	SCROLL_SRC,A3
	;MOVE.L	SCROLL_DEST,A4
	ADD.L	#bpl*(h/2-32),A4		; CENTER!
	ADD.L	#bpl/2-4,A4		; CENTER!
	bsr	WaitBlitter
	MOVE.W	BLIT_X_MASK,BLTAFWM	; BLTAFWM
	MOVE.W	BLIT_Y_MASK,BLTALWM	; BLTALWM
	MOVE.W	D1,BLTCON0		; BLTCON0 (usa A+D)
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1
	MOVE.W	#bpl-(64/16*2),BLTBMOD	; BLTAMOD
	MOVE.W	#0,BLTAMOD		; BLTBMOD =0 for texture
	MOVE.W	#bpl-(64/16*2),BLTDMOD	; BLTDMOD 40-4=36 il rettangolo

	MOVE.L	A3,BLTBPTH		; BLTAPT
	MOVE.L	#PATTERN1,BLTAPTH		; TEXTURE
	MOVE.L	A4,BLTCPTH
	MOVE.L	A4,BLTDPTH
	MOVE.W	#(64*64)+(64/16),BLTSIZE	; BLTSIZE (via al blitter !)
	; ## MAIN BLIT ####
	RTS

__SCROLL_X:
	MOVE.B	X_DIR,D5
	MOVE.W	#%0000100111110000,D1
	;MOVE.W	#%0000110111011100,D1
	CMP.B	#1,D5
	BEQ.B	.mainBlit
	; ## MAIN BLIT ####
	.mainBlit:
	MOVE.L	SCROLL_SRC,A3
	MOVE.L	SCROLL_DEST,A4
	ROL.W	#4,D1
	MOVE.B	X_SHIFT,D1
	ROR.W	#4,D1
	bsr	WaitBlitter
	MOVE.W	BLIT_X_MASK,BLTAFWM	; BLTAFWM lo spiegheremo dopo
	MOVE.W	BLIT_X_MASK,BLTALWM	; BLTALWM lo spiegheremo dopo
	MOVE.W	D1,BLTCON0		; BLTCON0 (usa A+D); con shift di un pixel
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1 BIT 12 DESC MODE
	MOVE.W	#0,BLTAMOD		; BLTAMOD =0 perche` il rettangolo
	MOVE.W	#0,BLTDMOD		; BLTDMOD 40-4=36 il rettangolo

	CMP.B	#1,D5
	BEQ.B	.goBlitter			; FOR LEFT
	ADD.L	#bpl*h-1,A3
	ADD.L	#bpl*h-1,A4
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 BIT 12 DESC MODE

	.goBlitter:
	MOVE.L	A3,BLTAPTH		; BLTAPT  (fisso alla figura sorgente)
	MOVE.L	A4,BLTDPTH
	;MOVE.L	#DITHERPLANE,BLTBPTH	; TEXTURE
	MOVE.W	#h*64+w/2/16,BLTSIZE	; BLTSIZE
	; ## MAIN BLIT ####
	RTS

__SCROLL_Y:
	bsr	WaitBlitter
	MOVE.W	#%0000100111110000,BLTCON0

	MOVE.L	#0,D1
	MOVE.B	Y_SHIFT,D1
	MULU.W	#bpl,D1

	; ## MAIN BLIT ####
	MOVE.L	SCROLL_SRC,A3
	MOVE.L	SCROLL_DEST,A4
	MOVE.B	Y_DIR,D5
	TST.B	D5
	BEQ.S	.goUp
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 DESC MODE
	ADD.L	D1,A4			; POSITION Y
	ADD.L	#bpl*(h-1)-2,A3
	ADD.L	#bpl*(h-1)-2,A4
	BRA.S	.goBlit
	.goUp:
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1
	ADD.L	D1,A3			; POSITION Y
	.goBlit:

	MOVE.W	BLIT_Y_MASK,BLTAFWM	; BLTAFWM
	MOVE.W	BLIT_Y_MASK,BLTALWM	; BLTALWM
	MOVE.W	#bpl-wblit,BLTAMOD		; BLTAMOD
	MOVE.W	#bpl-wblit,BLTDMOD		; BLTDMOD

	MOVE.L	A3,BLTAPTH		; BLTAPT SRC
	MOVE.L	A4,BLTDPTH		; DESC
	MOVE.W	#(h-3)*64+(w/2)/16,BLTSIZE	; BLTSIZE
	; ## MAIN BLIT ####
	RTS

__SCROLL_X_HALF:
	MOVE.B	X_HALF_DIR,D5
	NOT.B	D5
	MOVE.B	D5,X_HALF_DIR

	MOVE.W	#%0000100111110000,D1

	ADD.L	#(w/2/16*2),SCROLL_DEST
	ADD.L	#(w/2/16*2),SCROLL_SRC

	CMP.B	#1,D5
	BEQ.B	.mainBlit
	; ## FOR LEFT ####
	SUB.L	#(w/2/16*2),SCROLL_DEST	; THIS IS...
	SUB.L	#(w/2/16*2),SCROLL_SRC	; ...UGLY...
	MOVE.L	SCROLL_SRC,A3
	MOVE.L	SCROLL_DEST,A4		; PATCH FIRST WORD COLUMN
	bsr	WaitBlitter
	MOVE.L	A3,BLTAPTH		; BLTAPT  (fisso alla figura sorgente)
	ADD.L	#bpl-2,A4			; POSITION FOR DESC
	MOVE.L	A4,BLTDPTH
	MOVE.W	#$FFFF,BLTAFWM		; BLTAFWM lo spiegheremo dopo
	MOVE.W	#$FFFF,BLTALWM		; BLTALWM lo spiegheremo dopo
	MOVE.W	D1,BLTCON0		; BLTCON0 (usa A+D); con shift di un pixel
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1 BIT 12 DESC MODE
	MOVE.W	#bpl-2,BLTAMOD		; BLTAMOD =0 perche` il rettangolo
	MOVE.W	#bpl-2,BLTDMOD		; BLTDMOD 40-4=36 il rettangolo

	;MOVE.W	#(hblit<<6)+%000001,BLTSIZE	; BLTSIZE (via al blitter !)
	; ## FOR LEFT ####

	; ## MAIN BLIT ####
	.mainBlit:
	MOVE.L	SCROLL_SRC,A3
	MOVE.L	SCROLL_DEST,A4
	ROL.W	#4,D1
	MOVE.B	X_HALF_SHIFT,D1
	ROR.W	#4,D1
	bsr	WaitBlitter
	MOVE.W	BLIT_X_MASK,BLTAFWM	; BLTAFWM lo spiegheremo dopo
	MOVE.W	BLIT_X_MASK,BLTALWM	; BLTALWM lo spiegheremo dopo
	MOVE.W	D1,BLTCON0		; BLTCON0 (usa A+D); con shift di un pixel
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1 BIT 12 DESC MODE
	MOVE.W	#bpl-wblit,BLTAMOD		; BLTAMOD
	MOVE.W	#bpl-wblit,BLTDMOD		; BLTDMOD

	CMP.B	#1,D5
	BEQ.B	.goBlitter			; FOR LEFT
	ADD.L	#bpl*h-wblit-4,A3
	ADD.L	#bpl*h-wblit-4,A4
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 BIT 12 DESC MODE

	.goBlitter:
	MOVE.L	A3,BLTAPTH		; BLTAPT  (fisso alla figura sorgente)
	MOVE.L	A4,BLTDPTH
	MOVE.W	#h*64+(w/2)/16,BLTSIZE	; BLTSIZE
	; ## MAIN BLIT ####

	CMP.B	#1,D5
	BNE.B	.skip
	
	; ## FOR RIGHT ####
	MOVE.L	SCROLL_SRC,A3
	MOVE.L	SCROLL_DEST,A4		; PATCH FIRST WORD COLUMN
	bsr	WaitBlitter
	MOVEQ	#bpl-2,D0
	MOVE.L	A3,BLTAPTH		; BLTAPT  (fisso alla figura sorgente)
	MOVE.L	A4,BLTDPTH
	ADD.L	D0,A4
	MOVE.L	A4,BLTBPTH
	MOVE.W	#%0000110111100100,BLTCON0	; d = ac+b!c = abc+a!bc+ab!c+!ab!c = %11100100 = $e4
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1 BIT 12 DESC MODE
	MOVE.B	X_HALF_SHIFT,D1
	MOVE.W	#$FFFF,D2
	LSR.W	D1,D2

	MOVE.W	D2,BLTCDAT
	MOVE.W	D0,BLTAMOD
	MOVE.W	D0,BLTBMOD
	MOVE.W	D0,BLTDMOD

	;MOVE.W	#(hblit<<6)+%000001,BLTSIZE	; BLTSIZE (via al blitter !)
	.skip:
	; ## FOR RIGHT ####

	ADD.B	#1,X_HALF_SHIFT
	RTS

__SCROLL_Y_HALF:
	bsr	WaitBlitter
	MOVE.W	#%0000100111110000,BLTCON0

	MOVE.L	#0,D1
	MOVE.B	Y_HALF_SHIFT,D1
	;SUB.B	#2,D1
	MULU.W	#bpl,D1

	; ## MAIN BLIT ####
	MOVE.L	SCROLL_SRC,A3
	MOVE.L	SCROLL_DEST,A4
	MOVE.B	Y_DIR,D5
	NOT.B	D5
	MOVE.B	D5,Y_DIR
	TST.B	D5
	BEQ.S	.goUp
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 DESC MODE
	ADD.L	D1,A4			; POSITION Y
	ADD.L	#bpl*h-2,A3
	ADD.L	#bpl*h-2,A4
	BRA.S	.goBlit
	.goUp:
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1
	;SUB.B	#bpl,D1
	ADD.L	D1,A3			; POSITION Y
	.goBlit:

	MOVE.W	BLIT_Y_MASK,BLTAFWM	; BLTAFWM
	MOVE.W	BLIT_Y_MASK,BLTALWM	; BLTALWM
	MOVE.W	#0,BLTAMOD		; BLTAMOD =0 perche` il rettangolo
	MOVE.W	#0,BLTDMOD		; BLTDMOD 40-4=36 il rettangolo

	MOVE.L	A3,BLTAPTH		; BLTAPT SRC
	MOVE.L	A4,BLTDPTH		; DESC
	MOVE.W	#hblit*64+w/16,BLTSIZE	; BLTSIZE
	; ## MAIN BLIT ####

	ADD.B	#1,Y_HALF_SHIFT

	RTS

__SCROLL_X_FULL:
	; CHECK WORD!
	MOVE.B	X_FULL_DIR,D5
	MOVE.W	#1,D2			; FOR LOOP
	; ## TOP SLICE ##

	; ## TOP BLIT ####
	.blitLoop:
	MOVE.W	#%0000100111110000,D1
	MOVE.L	SCROLL_SRC,A3
	MOVE.L	SCROLL_DEST,A4
	ROL.W	#4,D1
	MOVE.B	X_FULL_SHIFT,D1
	ROR.W	#4,D1
	bsr	WaitBlitter
	MOVE.W	BLIT_X_MASK,BLTAFWM	; BLTAFWM lo spiegheremo dopo
	MOVE.W	BLIT_X_MASK,BLTALWM	; BLTALWM lo spiegheremo dopo
	MOVE.W	D1,BLTCON0		; BLTCON0 (usa A+D); con shift di un pixel
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1 BIT 12 DESC MODE
	MOVE.W	#0,BLTAMOD		; BLTAMOD =0 perche` il rettangolo
	MOVE.W	#0,BLTDMOD		; BLTDMOD 40-4=36 il rettangolo

	CMP.B	#1,D5
	BEQ.B	.goBlit			; FOR LEFT
	ADD.L	#bpl*hblit-1,A3
	ADD.L	#bpl*hblit-1,A4
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 BIT 12 DESC MODE

	.goBlit:
	MOVE.L	A3,BLTAPTH		; BLTAPT  (fisso alla figura sorgente)
	MOVE.L	A4,BLTDPTH
	MOVE.W	#(122<<6)+%00010101,BLTSIZE	; BLTSIZE (via al blitter !)
	; ## TOP BLIT ####

	ADD.L	#bpl*hblit,SCROLL_DEST
	ADD.L	#bpl*hblit,SCROLL_SRC
	NEG.B	D5
	DBRA	D2,.blitLoop

	;ADD.B	#1,X_FULL_SHIFT
	RTS

__SCROLL_Y_FULL:
	MOVEQ	#0,D5			; CLR
	MOVE.B	Y_FULL_DIR,D5
	MOVEQ	#0,D1			; CLR
	MOVE.B	Y_FULL_SHIFT,D1
	MOVE.W	#1,D2			; FOR LOOP
	MOVE.L	SCROLL_SRC,SCROLL_SRC_T
	MOVE.L	SCROLL_DEST,SCROLL_DEST_T

	MOVEQ	#0,D4			; CLR
	MOVE.W	#h,D4
	ADD.B	#1,D1			; FIX FOR -1 VALUES
	SUB.W	D1,D4
	SUB.W	#1,D4			; FIX FOR -1 VALUES
	MULU.W	#64,D4
	ADD.W	#wblit/2,D4

	MULU.W	#bpl,D1

	.blitLoop:
	; ## MAIN BLIT ####
	MOVE.L	SCROLL_SRC_T,A3
	MOVE.L	SCROLL_DEST_T,A4

	bsr	WaitBlitter
	MOVE.W	#%0000100111110000,BLTCON0

	CMP.B	#1,D5
	BEQ.S	.goUp
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 DESC MODE
	SUB.L	D1,A3			; POSITION Y
	ADD.L	#bpl*h-wblit-1,A3
	ADD.L	#bpl*h-wblit-1,A4
	BRA.S	.goBlit
	.goUp:
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1
	ADD.L	D1,A3			; POSITION Y
	.goBlit:

	MOVE.W	BLIT_Y_MASK,BLTAFWM	; BLTAFWM
	MOVE.W	BLIT_Y_MASK,BLTALWM	; BLTALWM
	MOVE.W	#bpl-wblit,BLTAMOD		; BLTAMOD
	MOVE.W	#bpl-wblit,BLTDMOD		; BLTDMOD

	MOVE.L	A3,BLTAPTH		; BLTAPT SRC
	MOVE.L	A4,BLTDPTH		; DESC

	;MOVE.W	#h*64+wblit/2,BLTSIZE	; BLTSIZE
	MOVE.W	D4,BLTSIZE		; BLTSIZE

	ADD.L	#wblit,SCROLL_DEST_T
	ADD.L	#wblit,SCROLL_SRC_T

	NEG.B	D5
	DBRA	D2,.blitLoop
	; ## MAIN BLIT ####

	RTS

__SCROLL_X_PROGR:
	MOVE.B	X_PROGR_DIR,D5
	MOVE.W	#8,D2			; FOR LOOP
	MOVE.B	D2,D3			; FOR SHIFT
	SUB.B	#1,D2
	MOVE.B	X_PROGR_TYPE,D6
	MOVE.L	SCROLL_SRC,SCROLL_SRC_T
	MOVE.L	SCROLL_DEST,SCROLL_DEST_T

	CMP.B	#1,D6
	BNE.S	.blitloop
	MOVE.B	#1,D3

	.blitLoop:
	;ADD.W	#1,D3			; TO SPEED UP
	MOVE.L	SCROLL_SRC_T,A3
	MOVE.L	SCROLL_DEST_T,A4
	MOVE.W	#%0000100111110000,D1
	ROL.W	#4,D1
	MOVE.B	D3,D1
	ROR.W	#4,D1
	bsr	WaitBlitter
	MOVE.W	BLIT_X_MASK,BLTAFWM	; BLTAFWM lo spiegheremo dopo
	MOVE.W	BLIT_X_MASK,BLTALWM	; BLTALWM lo spiegheremo dopo
	MOVE.W	D1,BLTCON0		; BLTCON0 (usa A+D); con shift di un pixel
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1 BIT 12 DESC MODE
	MOVE.W	#0,BLTAMOD		; BLTAMOD =0 perche` il rettangolo
	MOVE.W	#0,BLTDMOD		; BLTDMOD 40-4=36 il rettangolo

	CMP.B	#1,D5
	BEQ.B	.goBlit			; FOR LEFT
	ADD.L	#bpl*32-1,A3
	ADD.L	#bpl*32-1,A4
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 BIT 12 DESC MODE

	.goBlit:
	MOVE.L	A3,BLTAPTH		; BLTAPT  (fisso alla figura sorgente)
	MOVE.L	A4,BLTDPTH
	MOVE.W	#32*64+w/16,BLTSIZE	; BLTSIZE

	ADD.L	#bpl*32,SCROLL_SRC_T
	ADD.L	#bpl*32,SCROLL_DEST_T
	ADD.B	D6,D3			; CAN BE 1 OR -1
	;NEG.B	D5
	DBRA	D2,.blitLoop

	RTS

__SCROLL_Y_PROGR:
	MOVEQ	#0,D1			; RESETS...
	MOVEQ	#0,D2
	MOVEQ	#0,D3
	MOVEQ	#0,D4
	MOVEQ	#0,D5
	MOVEQ	#0,D6
	MOVEQ	#0,D7

	MOVE.B	Y_PROGR_DIR,D5
	MOVE.W	#10,D2			; FOR LOOP
	MOVE.B	D2,D3			; FOR SHIFT
	SUB.B	#1,D2
	MOVE.B	Y_PROGR_TYPE,D6
	MOVE.L	#0,D7
	MOVE.B	#vbarwbpl*2,D7
	MOVE.L	SCROLL_SRC,SCROLL_SRC_T
	MOVE.L	SCROLL_DEST,SCROLL_DEST_T

	CMP.B	#1,D6
	BNE.S	.blitloop
	MOVE.B	#1,D3			; OF POLARITY + THEN START FROM 1
	.blitLoop:
	MOVE.W	#h,D4
	SUB.W	D3,D4
	MULU.W	#64,D4
	ADD.W	#vbarwbpl,D4		; #h*64+vbarwbpl,BLTSIZE	; BLTSIZE
	MOVE.W	#bpl,D1
	;ADD.W	#1,D3			; TO SPEED UP
	MULU.W	D3,D1

	MOVE.L	SCROLL_SRC_T,A3
	MOVE.L	SCROLL_DEST_T,A4

	bsr	WaitBlitter
	MOVE.W	#%0000100111110000,BLTCON0

	CMP.B	#1,D5
	BEQ.S	.goUp
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 DESC MODE
	SUB.L	D1,A3			; POSITION Y
	ADD.L	#bpl*h-1,A3
	ADD.L	#bpl*h-1,A4
	BRA.S	.goBlit
	.goUp:
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1
	ADD.L	D1,A3			; POSITION Y
	.goBlit:

	MOVE.W	BLIT_Y_MASK,BLTAFWM	; BLTAFWM
	MOVE.W	BLIT_Y_MASK,BLTALWM	; BLTALWM
	MOVE.W	#bpl-vbarwbpl*2,BLTAMOD	; BLTAMOD
	MOVE.W	#bpl-vbarwbpl*2,BLTDMOD	; BLTDMOD

	MOVE.L	A3,BLTAPTH		; BLTAPT SRC
	MOVE.L	A4,BLTDPTH		; DESC

	MOVE.W	D4,BLTSIZE		; BLTSIZE

	CMP.B	#1,D5
	BNE.S	.notDesc
	ADD.L	D7,SCROLL_SRC_T
	ADD.L	D7,SCROLL_DEST_T
	BRA.S	.skip
	.notDesc:
	SUB.L	D7,SCROLL_SRC_T
	SUB.L	D7,SCROLL_DEST_T
	.skip:

	ADD.B	D6,D3			; CAN BE 1 OR -1
	;NEG.B	D6
	DBRA	D2,.blitLoop

	RTS

__SCROLL_X_PROGR_SPLIT:
	MOVE.B	X_PROGR_DIR,D5
	MOVE.W	#13,D2			; FOR LOOP
	MOVE.B	D2,D3			; FOR SHIFT
	SUB.B	#1,D2
	MOVE.B	X_PROGR_TYPE,D6
	MOVE.L	SCROLL_SRC,SCROLL_SRC_T
	MOVE.L	SCROLL_DEST,SCROLL_DEST_T

	CMP.B	#1,D6
	BNE.S	.blitloop
	MOVE.B	#1,D3

	.blitLoop:
	MOVE.L	SCROLL_SRC_T,A3
	MOVE.L	SCROLL_DEST_T,A4
	MOVE.W	#%0000100111110000,D1
	ROL.W	#4,D1
	MOVE.B	D3,D1
	ROR.W	#4,D1
	bsr	WaitBlitter
	MOVE.W	BLIT_X_MASK,BLTAFWM	; BLTAFWM lo spiegheremo dopo
	MOVE.W	BLIT_X_MASK,BLTALWM	; BLTALWM lo spiegheremo dopo
	MOVE.W	D1,BLTCON0		; BLTCON0 (usa A+D); con shift di un pixel
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1 BIT 12 DESC MODE
	MOVE.W	#0,BLTAMOD		; BLTAMOD =0 perche` il rettangolo
	MOVE.W	#0,BLTDMOD		; BLTDMOD 40-4=36 il rettangolo

	CMP.B	#1,D5
	BEQ.B	.goBlit			; FOR LEFT
	ADD.L	#bpl*Y_SLIDE-1,A3
	ADD.L	#bpl*Y_SLIDE-1,A4
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 BIT 12 DESC MODE

	.goBlit:
	MOVE.L	A3,BLTAPTH		; BLTAPT  (fisso alla figura sorgente)
	MOVE.L	A4,BLTDPTH
	MOVE.W	#Y_SLIDE*64+w/16,BLTSIZE	; BLTSIZE

	ADD.L	#bpl*Y_SLIDE,SCROLL_SRC_T
	ADD.L	#bpl*Y_SLIDE,SCROLL_DEST_T
	ADD.B	D6,D3			; CAN BE 1 OR -1

	CMP.W	#8,D3
	BNE.S	.notHalfScreen
	NEG.B	D5
	.notHalfScreen:
	DBRA	D2,.blitLoop
	RTS

__SCROLL_X_PROGR_SPLITX2:
	MOVE.B	X_PROGR_DIR,D5
	MOVE.B	#-1,D6
	MOVE.W	#1,D4			; FOR LOOP
	MOVE.L	SCROLL_SRC,SCROLL_SRC_T
	MOVE.L	SCROLL_DEST,SCROLL_DEST_T

	.outerLoop:
	MOVE.W	#9,D2			; FOR LOOP
	MOVE.B	D2,D3			; FOR SHIFT
	SUB.B	#1,D2

	CMP.B	#1,D6
	BNE.S	.blitloop
	MOVE.B	#1,D3

	.blitLoop:
	MOVE.L	SCROLL_SRC_T,A3
	MOVE.L	SCROLL_DEST_T,A4
	MOVE.W	#%0000100111110000,D1
	ROL.W	#4,D1
	MOVE.B	D3,D1
	ROR.W	#4,D1
	bsr	WaitBlitter
	MOVE.W	BLIT_X_MASK,BLTAFWM	; BLTAFWM lo spiegheremo dopo
	MOVE.W	BLIT_X_MASK,BLTALWM	; BLTALWM lo spiegheremo dopo
	MOVE.W	D1,BLTCON0		; BLTCON0 (usa A+D); con shift di un pixel
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1 BIT 12 DESC MODE
	MOVE.W	#0,BLTAMOD		; BLTAMOD =0 perche` il rettangolo
	MOVE.W	#0,BLTDMOD		; BLTDMOD 40-4=36 il rettangolo

	CMP.B	#1,D5
	BEQ.B	.goBlit			; FOR LEFT
	ADD.L	#bpl*Y_SLIDEPR-1,A3
	ADD.L	#bpl*Y_SLIDEPR-1,A4
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 BIT 12 DESC MODE

	.goBlit:
	MOVE.L	A3,BLTAPTH		; BLTAPT  (fisso alla figura sorgente)
	MOVE.L	A4,BLTDPTH
	MOVE.W	#Y_SLIDEPR*64+w/16,BLTSIZE	; BLTSIZE

	ADD.L	#bpl*Y_SLIDEPR,SCROLL_SRC_T
	ADD.L	#bpl*Y_SLIDEPR,SCROLL_DEST_T
	ADD.B	D6,D3			; CAN BE 1 OR -1

	DBRA	D2,.blitLoop
	NEG.B	D5
	NEG.B	D6
	DBRA	D4,.outerLoop
	RTS

__SCROLL_X_1_4:
	MOVE.W	#%0000100111110000,D1
	MOVE.B	X_1_4_DIR,D5
	CMP.B	#1,D5
	BEQ.B	.mainBlit
	; ## MAIN BLIT ####
	.mainBlit:
	MOVE.L	SCROLL_SRC,A3
	MOVE.L	SCROLL_DEST,A4
	ROL.W	#4,D1
	MOVE.B	X_1_4_SHIFT,D1
	ROR.W	#4,D1
	bsr	WaitBlitter
	MOVE.W	BLIT_X_MASK,BLTAFWM	; BLTAFWM lo spiegheremo dopo
	MOVE.W	BLIT_X_MASK,BLTALWM	; BLTALWM lo spiegheremo dopo
	MOVE.W	D1,BLTCON0		; BLTCON0 (usa A+D); con shift di un pixel
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1 BIT 12 DESC MODE
	MOVE.W	#bpl/2,BLTAMOD		; BLTAMOD =0 perche` il rettangolo
	MOVE.W	#bpl/2,BLTDMOD		; BLTDMOD 40-4=36 il rettangolo

	CMP.B	#1,D5
	BEQ.B	.goBlitter			; FOR LEFT
	ADD.L	#bpl*h/2-(bpl/2)-1,A3
	ADD.L	#bpl*h/2-(bpl/2)-1,A4
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 BIT 12 DESC MODE

	.goBlitter:
	MOVE.L	A3,BLTAPTH		; BLTAPT  (fisso alla figura sorgente)
	MOVE.L	A4,BLTDPTH
	MOVE.W	#(h/2)*64+w/2/16,BLTSIZE	; BLTSIZE
	; ## MAIN BLIT ####
	RTS

__SCROLL_Y_1_4:
	bsr	WaitBlitter
	MOVE.W	#%0000100111110000,BLTCON0

	MOVE.L	#0,D1
	MOVE.B	Y_1_4_SHIFT,D1
	MULU.W	#bpl,D1

	; ## MAIN BLIT ####
	MOVE.L	SCROLL_SRC,A3
	MOVE.L	SCROLL_DEST,A4
	MOVE.B	Y_1_4_DIR,D5
	CMP.B	#1,D5
	BEQ.S	.goUp
	MOVE.W	#%0000000000000010,BLTCON1	; BLTCON1 DESC MODE
	ADD.L	D1,A4			; POSITION Y
	ADD.L	#bpl*h/2-(bpl/2)-1,A3
	ADD.L	#bpl*h/2-(bpl/2)-1,A4
	BRA.S	.goBlit
	.goUp:
	MOVE.W	#%0000000000000000,BLTCON1	; BLTCON1
	ADD.L	D1,A3			; POSITION Y
	.goBlit:

	MOVE.W	BLIT_Y_MASK,BLTAFWM	; BLTAFWM
	MOVE.W	BLIT_Y_MASK,BLTALWM	; BLTALWM
	MOVE.W	#bpl/2,BLTAMOD		; BLTAMOD =0 perche` il rettangolo
	MOVE.W	#bpl/2,BLTDMOD		; BLTDMOD 40-4=36 il rettangolo

	MOVE.L	A3,BLTAPTH		; BLTAPT SRC
	MOVE.L	A4,BLTDPTH		; DESC
	MOVE.W	#(h/2)*64+w/2/16,BLTSIZE	; BLTSIZE
	; ## MAIN BLIT ####
	RTS

__X_SHIFT_LFO:
	MOVEQ	#0,D0			; RESETS...
	MOVEQ	#0,D1			; RESETS...
	MOVE.B	X_SHIFT_LFO,D1
	MOVE.B	X_FULL_SHIFT,D0

	CMP.B	X_SHIFT_LFO_MIN,D0
	BEQ.S	.changeDir

	CMP.B	X_SHIFT_LFO_MAX,D0	; TO DO - PARAMETER
	BNE.S	.sameDir
	.changeDir:
	NEG.B	D1
	
	TST.B	X_LFO_INVERT_DIR
	BEQ.S	.sameDir
	MOVE.B	X_FULL_DIR,D5
	NEG.B	D5
	MOVE.B	D5,X_FULL_DIR
	MOVE.B	X_PROGR_DIR,D5
	NEG.B	D5
	MOVE.B	D5,X_PROGR_DIR
	MOVE.B	X_PROGR_TYPE,D5
	NEG.B	D5
	MOVE.B	D5,X_PROGR_TYPE
	.sameDir:
	ADD.B	D1,D0
	MOVE.B	D1,X_SHIFT_LFO
	MOVE.B	D0,X_FULL_SHIFT
	RTS

__Y_SHIFT_LFO:
	MOVEQ	#0,D0			; RESETS...
	MOVEQ	#0,D1			; RESETS...
	MOVE.B	Y_SHIFT_LFO,D1
	MOVE.B	Y_FULL_SHIFT,D0

	CMP.B	Y_SHIFT_LFO_MIN,D0
	BEQ.S	.changeDir

	CMP.B	Y_SHIFT_LFO_MAX,D0	; TO DO - PARAMETER
	BNE.S	.sameDir
	.changeDir:
	NEG.B	D1
	
	TST.B	Y_LFO_INVERT_DIR
	BEQ.S	.sameDir
	MOVE.B	Y_FULL_DIR,D5
	NEG.B	D5
	MOVE.B	D5,Y_FULL_DIR
	MOVE.B	Y_PROGR_DIR,D5
	NEG.B	D5
	MOVE.B	D5,Y_PROGR_DIR
	MOVE.B	Y_PROGR_TYPE,D5
	NEG.B	D5
	MOVE.B	D5,Y_PROGR_TYPE
	.sameDir:
	ADD.B	D1,D0
	MOVE.B	D1,Y_SHIFT_LFO
	MOVE.B	D0,Y_FULL_SHIFT
	RTS

__BLOCK_TEST_Y:
	MOVE.W	#$FFFF,BLIT_X_MASK
	MOVE.W	#$FFFF,BLIT_Y_MASK

	MOVE.B	#1,Y_1_4_SHIFT
	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST

	ADD.L	#bpl/2,SCROLL_SRC
	ADD.L	#bpl/2,SCROLL_DEST

	MOVE.B	#1,Y_1_4_DIR
	BSR.W	__SCROLL_Y_1_4

	ADD.L	#bpl*h/2-(bpl/2)-bpl,SCROLL_SRC
	ADD.L	#bpl*h/2-(bpl/2)-bpl,SCROLL_DEST
	
	MOVE.B	#-1,Y_1_4_DIR
	BSR.W	__SCROLL_Y_1_4

	MOVE.L	BGPLANE1,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST

	ADD.L	#bpl/2,SCROLL_SRC
	ADD.L	#bpl/2,SCROLL_DEST

	MOVE.B	#1,Y_1_4_DIR
	BSR.W	__SCROLL_Y_1_4

	ADD.L	#bpl*h/2-(bpl/2)-bpl,SCROLL_SRC
	ADD.L	#bpl*h/2-(bpl/2)-bpl,SCROLL_DEST
	
	MOVE.B	#-1,Y_1_4_DIR
	BSR.W	__SCROLL_Y_1_4

	MOVE.L	GLITCHGOOD,SCROLL_SRC
	BSR.W	__BLIT_GLITCH_TILE
	ADD.L	#bpl,GLITCHGOOD

	MOVE.W	#1,P61_LAST_POS
	RTS

__BLOCK_TEST_X:
	MOVE.W	#$FFFF,BLIT_X_MASK
	MOVE.W	#$FFFF,BLIT_Y_MASK

	MOVE.B	#2,X_1_4_SHIFT
	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST

	MOVE.B	#-1,X_1_4_DIR
	BSR.W	__SCROLL_X_1_4

	ADD.L	#bpl*h/2-(bpl/2),SCROLL_SRC
	ADD.L	#bpl*h/2-(bpl/2),SCROLL_DEST
	
	MOVE.B	#1,X_1_4_DIR
	BSR.W	__SCROLL_X_1_4

	MOVE.L	BGPLANE1,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST
	MOVE.B	#-1,X_1_4_DIR
	BSR.W	__SCROLL_X_1_4

	ADD.L	#bpl*h/2-(bpl/2),SCROLL_SRC
	ADD.L	#bpl*h/2-(bpl/2),SCROLL_DEST
	
	MOVE.B	#1,X_1_4_DIR
	BSR.W	__SCROLL_X_1_4

	MOVE.L	DITHERPLANE,SCROLL_SRC
	BSR.W	__BLIT_GLITCH_TILE

	MOVE.W	#0,P61_LAST_POS
	RTS

__BLOCK_SCREEN:
	MOVE.W	#$FFFF,BLIT_X_MASK
	MOVE.W	#$FFFF,BLIT_Y_MASK

	MOVE.B	#0,X_SHIFT
	MOVE.L	GLITCHGOOD,SCROLL_SRC

	MOVE.L	BGPLANE0,SCROLL_DEST
	MOVE.B	#1,X_DIR
	BSR.W	__SCROLL_X
	MOVE.B	#0,X_DIR
	BSR.W	__SCROLL_X
	ADD.L	#bpl,GLITCHGOOD
	MOVE.L	BGPLANE1,SCROLL_DEST
	MOVE.B	#1,X_DIR
	BSR.W	__SCROLL_X
	MOVE.B	#0,X_DIR
	BSR.W	__SCROLL_X
	MOVE.W	#1,P61_LAST_POS
	RTS

__BLOCK_GLITCH:
	MOVE.W	#$FFFF,BLIT_X_MASK
	MOVE.W	#$FFFF,BLIT_Y_MASK

	MOVE.L	GLITCHDATA,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST
	BSR.W	__BLIT_GLITCH_TILE
	ADD.L	#2,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST
	BSR.W	__BLIT_GLITCH_TILE
	ADD.L	#bpl,GLITCHDATA
	RTS

__BLOCK_0:
	MOVE.W	#$FFFF,BLIT_X_MASK
	MOVE.W	#$FFFF,BLIT_Y_MASK

	TST.B	FRAME_STROBE
	BNE.S	.oddFrame
	MOVE.B	#1,FRAME_STROBE

	MOVE.B	#1,Y_LFO_INVERT_DIR
	;MOVE.B	#9,Y_SHIFT_LFO_MAX
	;MOVE.B	#3,Y_SHIFT_LFO_MIN
	BSR.W	__Y_SHIFT_LFO
	BSR.W	__Y_SHIFT_LFO
	;MOVE.B	#7,Y_FULL_SHIFT
	;MOVE.B	#15,Y_FULL_SHIFT

	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST
	BSR.W	__SCROLL_Y_FULL
	BSR.W	__SCROLL_X_PROGR_SPLITX2

	MOVE.L	BGPLANE1,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST
	BSR.W	__SCROLL_Y_FULL
	BSR.W	__SCROLL_X_PROGR_SPLITX2
	BSR.W	__BLIT_GLITCH_TILE
	BRA.S	.evenFrame

	.oddFrame:
	;MOVE.B	#0,FRAME_STROBE
	MOVE.B	#1,X_LFO_INVERT_DIR
	BSR.W	__X_SHIFT_LFO
	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST
	BSR.W	__SCROLL_Y_FULL
	BSR.W	__SCROLL_X_PROGR_SPLIT

	MOVE.L	BGPLANE1,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST
	BSR.W	__SCROLL_Y_FULL
	BSR.W	__SCROLL_X_PROGR_SPLIT

	MOVE.L	GLITCHGOOD,SCROLL_SRC
	BSR.W	__BLIT_GLITCH_TILE
	ADD.L	#2,GLITCHGOOD
	BSR.W	__BLIT_GLITCH_TILE
	MOVE.L	DITHERPLANE,SCROLL_SRC
	BSR.W	__BLIT_GLITCH_TILE
	.evenFrame:

	RTS

__BLOCK_1:
	MOVE.W	#$FFFF,BLIT_X_MASK
	MOVE.W	#$FFFF,BLIT_Y_MASK

	;MOVE.B	#1,Y_FULL_SHIFT

	BSR.W	__Y_SHIFT_LFO

	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST
	BSR.W	__SCROLL_Y_FULL
	BSR.W	__SCROLL_X_PROGR

	MOVE.L	BGPLANE1,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST
	BSR.W	__SCROLL_Y_FULL
	BSR.W	__SCROLL_X_PROGR

	MOVE.L	GLITCHGOOD,SCROLL_SRC
	BSR.W	__BLIT_GLITCH_TILE
	ADD.L	#bpl,GLITCHGOOD

	;MOVE.W	#0,P61_LAST_POS
	RTS

__BLOCK_2:
	MOVE.B	#0,Y_LFO_INVERT_DIR
	BSR.W	__Y_SHIFT_LFO

	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST
	BSR.W	__SCROLL_X_PROGR

	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST
	BSR.W	__SCROLL_Y_PROGR

	MOVE.L	BGPLANE1,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST
	BSR.W	__SCROLL_X_PROGR

	MOVE.L	BGPLANE1,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST
	BSR.W	__SCROLL_Y_PROGR
	BSR.W	__Y_SHIFT_LFO
	;MOVE.W	#1,P61_LAST_POS
	RTS

__BLOCK_3:
	MOVE.B	#2,X_SHIFT
	MOVE.B	#2,Y_SHIFT
	MOVE.B	#1,X_DIR
	MOVE.B	#1,Y_DIR
	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST
	;BSR.W	__SCROLL_X
	BSR.W	__SCROLL_Y
	MOVE.B	#-1,Y_DIR
	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST
	;BSR.W	__SCROLL_X		; SHIFT !!
	BSR.W	__SCROLL_Y		; SHIFT !!

	;MOVE.W	#0,P61_LAST_POS
	RTS

__BLOCK_4:
	; 0: EMPTY_BEGIN
	;MOVE.L	#0,V_SHIFT_FACT
	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST
	BSR.W	__SCROLL_X		; SHIFT !!

	;MOVE.B	#0,X_DIR
	MOVE.L	BGPLANE1,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST
	BSR.W	__SCROLL_X		; SHIFT !!

	SUB.B	#1,X_SHIFT

	MOVE.B	X_DIR,D5
	NOT.B	D5
	MOVE.B	D5,X_DIR

	MOVE.B	SCROLL_INDEX,D5
	ADD.B	#5,D5
	AND.B	#31,D5
	MOVE.B	D5,SCROLL_INDEX
	TST.B	D5
	;BNE.S	.skip
	;MOVE.B	#0,X_SHIFT
	;MOVE.B	X_DIR,D5
	;NOT.B	D5
	;MOVE.B	D5,X_DIR
	;ADD.B	#1,X_SHIFT
	;BRA.S	.skip2
	.skip:

	.skip2:

	ADD.L	#4,GLITCHDATA

	MOVE.L	V_SHIFT_FACT,D5
	;ADD.L	D5,BGPLANE1
	NEG.L	D5
	;ADD.L	D5,BGPLANE0

	MOVE.W	V_SCROLL_INDEX,D6
	ADD.W	#1,D6
	AND.W	#(hblit/2)-1,D6
	TST.W	D6
	BNE.S	.noReset
	MOVE.L	D5,V_SHIFT_FACT
	;MOVE.W	#$F00,$DFF180	; show rastertime left down to $12c
	.noReset:
	MOVE.W	D6,V_SCROLL_INDEX
	;BSR.W	__POPULATETXTBUFFER
	;BSR.W	__SHIFTTEXT
	RTS

__BLOCK_5:
	MOVE.B	#1,Y_LFO_INVERT_DIR
	BSR.W	__Y_SHIFT_LFO

	MOVE.L	BGPLANE0,SCROLL_SRC
	MOVE.L	BGPLANE0,SCROLL_DEST
	;BSR.W	__SCROLL_Y_FULL
	BSR.W	__SCROLL_X_PROGR_SPLITX2

	MOVE.L	BGPLANE1,SCROLL_SRC
	MOVE.L	BGPLANE1,SCROLL_DEST
	;BSR.W	__SCROLL_Y_FULL
	BSR.W	__SCROLL_X_PROGR_SPLITX2

	MOVE.L	GLITCHGOOD,SCROLL_SRC
	BSR.W	__BLIT_GLITCH_TILE
	ADD.L	#2,GLITCHGOOD
	BSR.W	__BLIT_GLITCH_TILE
	MOVE.L	DITHERPLANE,SCROLL_SRC
	BSR.W	__BLIT_GLITCH_TILE
	RTS

__BLOCK_END:
	; 0: EMPTY_BEGIN
	MOVE.W	P61_LAST_POS,D5
	CMP.W	#62,D5
	BNE.S	.dontStopMusic
	JSR	__CREATESCROLLSPACE
	MOVE.W	#%1000010000000000,DMACON	; BIT10=BLIT NASTY ENABLED

	MOVEM.L D0-A6,-(SP)
	JSR P61_End
	MOVEM.L (SP)+,D0-A6
	.dontStopMusic:

	MOVE.B	#1,X_DIR
	MOVE.L	BGPLANE0,SCROLL_DEST
	MOVE.B	#1,X_SHIFT
	BSR.W	__SCROLL_X		; SHIFT !!
	MOVE.B	#1,X_DIR
	MOVE.L	BGPLANE1,SCROLL_DEST
	MOVE.B	#2,X_SHIFT
	BSR.W	__SCROLL_X		; SHIFT !!
	MOVE.B	#1,X_DIR
	
	MOVE.W	#61,P61_LAST_POS		; REPEAT ?
	MOVE.W	#23,P61_DUMMY_POS		; ANY VALUE

	RTS

__COPCOL_EDIT:
	LEA	COPPER\.Palette,A0
	ADD.L	COPCOL_REGISTER,A0
	MOVE.W	COPCOL_ADDER,D2	; COLOR ADDER
	; TODO - CHECK IF COLORE REGISTER
	; **** JOYSTICK TEST ****
	MOVEM.W	$DFF00C,D0	; FROM EAB
	ANDI.W	#$0303,D0
	MOVE.W	D0,D1
	ADD.W	D1,D1
	ADDI.W	#$0101,D0
	ADD.W	D1,D0
	BTST	#$07,$BFE001	; FIRE
	BNE.W	.notFire

	BTST	#9,D0		; 9 LEFT
	BEQ.S	.notLeft
	TST.W	JOYDIR_STATUS
	BNE.W	.SkipJoyActions
	MOVE.W	#1,JOYDIR_STATUS
	ROL.W	#4,D2
	CMPI.W	#$1000,D2
	BNE.S	.notLeft
	MOVE.W	#$0001,D2
	.notLeft:
	BTST	#1,D0		; 1 RIGHT
	BEQ.S	.notRight
	TST.W	JOYDIR_STATUS
	BNE.W	.SkipJoyActions
	MOVE.W	#1,JOYDIR_STATUS
	ROR.W	#4,D2
	CMPI.W	#$1000,D2
	BNE.S	.notRight
	MOVE.W	#$0100,D2
	.notRight:
	BTST	#2,D0		; 10 UP
	BEQ.S	.notDown
	TST.W	JOYDIR_STATUS
	BNE.W	.SkipJoyActions
	MOVE.W	#1,JOYDIR_STATUS
	SUB.W	D2,2(A0)
	.notDown:
	BTST	#10,D0		; 2 DOWN
	BEQ.S	.notUp
	TST.W	JOYDIR_STATUS
	BNE.W	.SkipJoyActions
	MOVE.W	#1,JOYDIR_STATUS
	ADD.W	D2,2(A0)
	.notUp:

	MOVE.W	D2,COPCOL_ADDER	; COLOR ADDER
	BRA.S	.SkipJoyActions

	.notFire:
	BTST	#9,D0		; 9 LEFT
	BEQ.S	.notLeft1
	TST.W	JOYDIR_STATUS
	BNE.W	.SkipJoyActions
	MOVE.W	#1,JOYDIR_STATUS
	TST.L	COPCOL_REGISTER
	BEQ.S	.notLeft1		; NO DECREASE IF 0...
	SUB.L	#4,COPCOL_REGISTER
	MOVE.W	#$0100,D2		; COLOR ADDER
	.notLeft1:
	BTST	#1,D0		; 1 RIGHT
	BEQ.S	.notRight1
	TST.W	JOYDIR_STATUS
	BNE.W	.SkipJoyActions
	MOVE.W	#1,JOYDIR_STATUS
	MOVE.W	#2,D3		; HOW MANY COLORS
	LSL.W	#bpls-1,D3
	MULU.W	#4,D3
	SUB.W	#4,D3
	MOVE.L	COPCOL_REGISTER,D4
	CMP.L	COPCOL_REGISTER,D3
	BEQ.S	.notRight1	; NO INCREASE IF LAST
	ADD.L	#4,COPCOL_REGISTER
	MOVE.W	#$0100,D2		; COLOR ADDER
	.notRight1:

	MOVE.W	D2,COPCOL_ADDER	; COLOR ADDER

	.SkipJoyActions:
	CMPI.W	#$00000101,D0
	BNE.S	.DontResetStatus
	MOVE.W	#0,JOYDIR_STATUS
	.DontResetStatus:
	; **** JOYSTICK TEST ****
	RTS

;********** Fastmem Data **********
DrawBuffer:	DC.L BG1		; pointers to buffers
ViewBuffer:	DC.L BG1		; to be swapped

TIMELINE:		DC.L __BLOCK_0,__BLOCK_0,__BLOCK_0
		DC.L __BLOCK_3,__BLOCK_4	; 1 1: Solo Robot
		DC.L __BLOCK_END

AUDIOCHLEVEL0NRM:	DC.W 0
AUDIOCHLEVEL0:	DC.W 0
AUDIOCHLEVEL1:	DC.W 0
AUDIOCHLEVEL2:	DC.W 0
AUDIOCHLEVEL3:	DC.W 0
P61_LAST_POS:	DC.W MODSTART_POS
P61_DUMMY_POS:	DC.W 0
P61_FRAMECOUNT:	DC.W 0

SCROLL_INDEX:	DC.W 0
SCROLL_DEST:	DC.L 0
SCROLL_SRC:	DC.L 0
SCROLL_DEST_T:	DC.L 0
SCROLL_SRC_T:	DC.L 0

X_SHIFT_LFO:	DC.B 1
X_SHIFT_LFO_MIN:	DC.B -1
X_SHIFT_LFO_MAX:	DC.B 15
X_LFO_INVERT_DIR:	DC.B 0

Y_SHIFT_LFO:	DC.B 1
Y_SHIFT_LFO_MIN:	DC.B -1
Y_SHIFT_LFO_MAX:	DC.B 15
Y_LFO_INVERT_DIR:	DC.B 0

X_DIR:		DC.B 1		; -1=LEFT 1=RIGHT
Y_DIR:		DC.B -1		; -1=LEFT 1=RIGHT
X_SHIFT:		DC.B 0
Y_SHIFT:		DC.B 1

X_HALF_DIR:	DC.B 0
Y_HALF_DIR:	DC.B 0
X_HALF_SHIFT:	DC.B 0
Y_HALF_SHIFT:	DC.B 0

X_FULL_DIR:	DC.B -1
Y_FULL_DIR:	DC.B 1
X_FULL_SHIFT:	DC.B 0
Y_FULL_SHIFT:	DC.B 0

X_PROGR_DIR:	DC.B -1
Y_PROGR_DIR:	DC.B 1
X_PROGR_TYPE:	DC.B -1
Y_PROGR_TYPE:	DC.B 1		; SOLO POSITIVO

X_1_4_DIR:	DC.B 1		; -1=LEFT 1=RIGHT
Y_1_4_DIR:	DC.B -1		; -1=LEFT 1=RIGHT
X_1_4_SHIFT:	DC.B 0
Y_1_4_SHIFT:	DC.B 1

SCROLL_DIR_0:	DC.B 1
SCROLL_DIR_1:	DC.B 1
SCROLL_DIR_2:	DC.B 1
SCROLL_DIR_3:	DC.B 1
FRAME_STROBE:	DC.B 0
		EVEN
TEXTINDEX:	DC.W 0
FRAMESINDEX:	DC.W 4
GLITCHDATA:	DC.L MODULE
GLITCHGOOD:	DC.L MODULE+bpl*h*7

GLITCHDESTTABLE:	DC.L PLANE0,PLANE1,PLANE0,PLANE1,PLANE0,PLANE1,PLANE0,PLANE1
GLITCH_INDEX:	DC.W 0

V_SHIFT_FACT:	DC.L bpl*2*-1
V_SCROLL_INDEX:	DC.W 0
BLIT_Y_MASK:	DC.W $FFFF
BLIT_X_MASK:	DC.W $FFFF
TOT_SHIFT_FACTOR:	DC.L 0

COPCOL_REGISTER:	DC.L 0
COPCOL_VALUE:	DC.W 0
COPCOL_INDEX:	DC.W 0
COPCOL_ADDER:	DC.W $0100
JOYFIRE_STATUS:	DC.W 0
JOYDIR_STATUS:	DC.W 0

BG1:
BGPLANE0:		DC.L PLANE0
BGPLANE1:		DC.L PLANE1
;BGPLANE2:	DC.L PLANE2	; DUMMY :)
BGPLANE3:		DC.L PLANE3	; FOR 3D
;BGPLANE4:	DC.L PLANE4	; FOR 5 BITPLANES?
DITHERPLANE:	DC.L BUFFERDITHER

	;*******************************************************************************
	SECTION	ChipData,DATA_C	;declared data that must be in chipmem
	;*******************************************************************************

BPLxMOD_INDEX:	DC.W 0
BPLxMOD_TABLE:	DC.W 1,3,4,1,12,5,4,7,1,4,3,1,0,2,6,10,7,3,2,1,5,4,1,8,7,6,5,1,8,0,1,8,0,3,1,7,17,4,30,3,6,1

SPRITES:		INCLUDE "sprite_KONEY.s"
MODULE:		INCBIN "KETAMUSkOLAR.med"
KONEY:
	DC.L %10001011111011111011111011011000
	DC.L %10010010001010001010000001110000
	DC.L %11100011001011001011111000100000
	DC.L %11010011001011001011000000110000
	DC.L %11001011111011001011111000110000
PATTERN1:		INCBIN "pattern_chaos.raw"

FONT:		DC.L 0,0		; SPACE CHAR
		INCBIN "digital_font.raw",0
		EVEN

TEXT:	DC.B "!!WARNING!! - EPILEPSY DANGER AHEAD!!   SERIOUSLY... :)    "
	DC.B "WELCOME TO:   ### CRIPPLED CYBORG ###   KONEY'S SECOND AMIGA HARDCORE RELEASE!   "
	DC.B "AS PROMISED MORE GLITCHES AND BLITSTORTIONS ARE BEING DELIVERED TO YOUR AMIGA. "
	DC.B "IT SHOULDN'T BE NECESSARY TO REMIND THAT THIS PIECE OF CRAPPY CODE IS BEST VIEWED "
	DC.B "ON A REAL AMIGA WITH A TRUE CRT DISPLAY AND BIG LOUDSPEAKERZ!! NO EMULATION FUCKERS, "
	DC.B "AN EMULATOR IS LIKE AN INFLATABLE SEXDOLL: YOU CAN HAVE FUN WITH IT BUT YOU CAN'T "
	DC.B "SAY YOU HAVE A GIRLFRIEND! SO FIRE UP YOUR REAL AMIGA IF YOU HAVEN'T ALREADY!  "
	DC.B "IT'S NOW TIME FOR THE REAL SCROLLTEXT: I PUBLISHED THIS TRACK ON MY OWN LABEL BACK "
	DC.B "IN 2000 WITH CAT# KNY-04 'PEOPLEGRINDER' BUT ACCORDINGLY TO THE NOTE INSIDE .MED FILE "
	DC.B "IT WAS COMPOSED BACK IN 1997. ODDLY THIS IS NOT WHAT I REMEMBER BUT WE WRITE NOTES ON "
	DC.B "STUFF TO REMEMBER THINGS SO I ASSUME IT WAS REALLY 1997! TWENTY FUCKING THREE "
	DC.B "YEARS AGO! ALL MY AMIGA MUSIC WAS MADE WITH OCTAMED SOUNDSTUDIO SO TO PUT ANY SONG "
	DC.B "INTO ASSEMBLY CODE A CONVERSION TO .MOD IS REQUIRED. THIS IS USUALLY AN EASY TASK "
	DC.B "BUT BACK IN THE DAYS I THOUGHT IT WAS A GOOD IDEA TO LOAD ANY KIND OF FILE AS "
	DC.B "SAMPLES INTO OCTAMED... IT TURNED OUT THEY DON'T PLAY AS GOOD IN P61, SOME OF THEM MAKE "
	DC.B "GLITCHES... I KNOW IT'S FUNNY TO SAY, GIVEN THE VISUALS AND THE REST OF THE SOUNDZ, "
	DC.B "BUT I WANTED THE INTRO TO SOUND AS CLOSE AS POSSIBLE TO THE ORIGINAL "
	DC.B "RECORDING ON VINYL SO I HAD SOME OF THIS SAMPLES RE-SAMPLED FROM-TO-AMIGA "
	DC.B "(THANKS KCMA!). ABOUT LOADING RANDOM FILES AS SAMPLES... TO BE HONEST I STILL THINK IT WAS "
	DC.B "A GOOD IDEA!! THE SAME WAY THESE DAYS I THINK IT IS A GOOD IDEA TO FEED SEMI-RANDOM VALUES "
	DC.B "INTO BPLXMOD REGISTERS, JUST FOR SOME EXTRA GLITCH FUN! AND IT WORKS, GURULESSLY!!   "
	DC.B "SO THERE'S A LOT OF BLITTING ACTION HERE, IT TOOK ME A WHILE BUT I MANAGED TO DO WHAT I HAD IN "
	DC.B "MIND AND FOR THIS I MUST THANK ALL THE GUYS FROM EAB DISCUSSION: 'BLITTER SHIFT EATING 1PX AWAY' "
	DC.B "WHICH RAN FOR ALMOST ONE YEAR! THANKS FOR YOUR PATIENCE! ANYWAY MY IDEA WAS TO "
	DC.B "SCROLL 4 SEPARATE BITPLANES (ONE PER AUDIO CHANNEL) BUT IT TURNS OUT THAT BLITTING "
	DC.B "SO MUCH DATA IN A SINGLE FRAME REQUIRES NASTY BLITTER BIT SET BUT I LEARNT THE HARD "
	DC.B "WAY WHAT PHOTON/SCOOPEX ONCE SAID: 'THE BLITTER IS VERY NASTY INDEED. BUT PAULA IS NASTIER!'...   "
	DC.B "SO ONLY 3 BITPLANE SCROLLED AT A TIME, WELL ANYWAY THERE IS ENOUGH MESS ON SCREEN ALREADY I GUESS :)  "
	DC.B "I'LL POST THIS INTRO IN POUET.NET, IF YOU ARE ONE OF THE NICE GUYS WHO UPVOTED "
	DC.B "MY FIRST INTRO 'FATAL DEFRAG' I WANT YOU TO KNOW THAT I REALLY APPRECIATE YOUR SUPPORT! "
	DC.B "SPEAKING OF POUET.NET I'VE JUST NOTICED A GUY CALLED 'KIMI KANDLER' HAS ADDED 'FATAL DEFRAG' "
	DC.B "TO A LIST OF PRODUCTIONS PRESSED ON VINYL, NICE ONE! HERE YOU HAVE MORE FOR YOUR LIST! "
	DC.B "FOR THE FUTURE I AM ALREADY THINKING AT THE NEXT INTRO WHICH WILL FEATURE ONE OF MY MOST "
	DC.B "ARCHETYPAL TRACKS: 'KETAMUSKOLAR' RELEASED BACK IN 2002 ON SONIC POLLUTION #02.    "
	DC.B "ONE LAST WORD BEFORE ABANDONING THE SCREEN TO THE GLITCHES... I AM ABANDONING THE "
	DC.B "SCREEN TO THE GLITCHES :) - MAKE SURE TO VISIT WWW.KONEY.ORG FOR MORE INDUSTRIAL "
	DC.B "AMIGACORE!!            .EOF                                                              "
	EVEN
_TEXT:

COPPER:
	DC.W $1FC,0	; Slow fetch mode, remove if AGA demo.
	DC.W $8E,$2C81	; 238h display window top, left | DIWSTRT - 11.393
	DC.W $90,$2CC1	; and bottom, right.	| DIWSTOP - 11.457
	DC.W $92,$38	; Standard bitplane dma fetch start
	DC.W $94,$D0	; and stop for standard screen.
	DC.W $106,$0C00	; (AGA compat. if any Dual Playf. mode)
	DC.W $108,0	; BPL1MOD	 Bitplane modulo (odd planes)
	DC.W $10A,0	; BPL2MOD Bitplane modulo (even planes)
	DC.W $102,0	; SCROLL REGISTER (AND PLAYFIELD PRI)

	.Palette:
	DC.W $0180,$0111,$0182,$0222,$0184,$0333,$0186,$0444
	DC.W $0188,$0555,$018A,$00A0,$018C,$0667,$018E,$0777
	DC.W $0190,$0888,$0192,$0888,$0194,$0999,$0196,$0AAA
	DC.W $0198,$0BBB,$019A,$0CCC,$019C,$0DDD,$019E,$0FFF
	DC.W $01A0,$0555,$01A2,$0444,$01A4,$0FF0,$01A6,$0EEF
	DC.W $01A8,$0BBC,$01AA,$099A,$01AC,$0F0F,$01AE,$00FF
	DC.W $01B0,$0888,$01B2,$0999,$01B4,$0AAA,$01B6,$0BBB
	DC.W $01B8,$0CCC,$01BA,$0DDD,$01BC,$0EEE,$01BE,$0FFF

	.SpritePointers:
	DC.W $120,0,$122,0	; 0
	DC.W $124,0,$126,0	; 1
	DC.W $128,0,$12A,0	; 2
	DC.W $12C,0,$12E,0	; 3
	DC.W $130,0,$132,0	; 4
	DC.W $134,0,$136,0	; 5
	DC.W $138,0,$13A,0	; 6
	DC.W $13C,0,$13E,0	; 7

	.BplPtrs:
	DC.W $E0,0
	DC.W $E2,0
	DC.W $E4,0
	DC.W $E6,0
	DC.W $E8,0
	DC.W $EA,0
	DC.W $EC,0
	DC.W $EE,0
	DC.W $F0,0
	DC.W $F2,0
	DC.W $F4,0
	DC.W $F6,0		;full 6 ptrs, in case you increase bpls
	DC.W $100,bpls*$1000+$200	;enable bitplanes

	.COPPERWAITS:
	DC.W $3801,$FF00		; ## START ##
	.BplPtrs2:
	DC.W $E0,0
	DC.W $E2,0
	DC.W $E4,0
	DC.W $E6,0
	DC.W $E8,0
	DC.W $EA,0
	DC.W $EC,0
	DC.W $EE,0

	DC.W $FFDF,$FFFE	; allow VPOS>$ff
	DC.W $2101,$FF00		; ## START ##
	.BplPtrs3:
	DC.W $E0,0
	DC.W $E2,0
	DC.W $E4,0
	DC.W $E6,0
	DC.W $E8,0
	DC.W $EA,0
	DC.W $EC,0
	DC.W $EE,0


	DC.W $FFFF,$FFFE	;magic value to end copperlist
_COPPER:

HEADER:		DS.B 11*bpl
		DCB.L 10,$FFFFFFFF
FOOTER:		DCB.L 10,$FFFFFFFF
		DS.B 10*bpl

;*******************************************************************************
	SECTION ChipBuffers,BSS_C	;BSS doesn't count toward exe size
;*******************************************************************************

SCREEN1:		DS.B 0		; Define storage for buffer 1
SCREEN2:		DS.B 0		; two buffers
PLANE0:		DS.B h*bpl
PLANE1:		DS.B h*bpl
;PLANE2:		DS.B h*bpl	; DUMMY :)
PLANE3:		DS.B h*bpl	; FOR 3D
;PLANE4:		DS.B h*bpl	; FOR 5 BITPLANES?
BUFFERDITHER:	DS.B h*bpl	; two buffers

END